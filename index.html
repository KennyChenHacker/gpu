<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TERMINAL LOAD: 100%</title>
    <style>
        body { margin: 0; background: #000; color: #00ff41; font-family: 'Courier New', monospace; overflow: hidden; }
        canvas { display: block; width: 100vw; height: 100vh; filter: contrast(1.2) brightness(1.1); }
        
        #ui {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0, 20, 0, 0.9); padding: 25px;
            border: 1px solid #00ff41; box-shadow: 0 0 20px #00ff41;
            pointer-events: none; z-index: 10;
        }

        .glitch { animation: glitch 0.2s infinite; color: #fff; font-size: 24px; font-weight: bold; }
        @keyframes glitch {
            0% { transform: translate(0); text-shadow: 2px 2px red; }
            50% { transform: translate(-2px, 2px); text-shadow: -2px -2px blue; }
            100% { transform: translate(0); }
        }

        .data { font-size: 14px; margin-top: 10px; color: #00ff41; border-top: 1px solid #00ff41; padding-top: 10px; }
    </style>
</head>
<body>

<div id="ui">
    <div class="glitch">STRESS LEVEL: ABSOLUTE</div>
    <div class="data">
        RENDER MODE: 16x SUPERSAMPLED (OVERKILL)<br>
        FRACTAL DEPTH: 500 ITERATIONS<br>
        SHADING: VOLUMETRIC NOISE + SPECULAR<br>
        <br>
        SYSTEM FPS: <span id="fps">--</span>
    </div>
</div>

<canvas id="glCanvas"></canvas>

<script>
    const canvas = document.getElementById('glCanvas');
    const gl = canvas.getContext('webgl');
    
    // We force the canvas to render at 2x the actual screen resolution 
    // before the SSAA even starts. This is "Super-Supersampling".
    const scale = 2.0; 
    canvas.width = window.innerWidth * scale;
    canvas.height = window.innerHeight * scale;

    const vsSource = `attribute vec2 pos; void main() { gl_Position = vec4(pos, 0, 1); }`;

    // The "Hardest" Shader: 16x SSAA + 500 Fractal Iterations + Complex Trig
    const fsSource = `
        precision highp float;
        uniform float uTime;
        uniform vec2 uRes;

        // Force expensive trigonometric noise
        float noise(vec3 p) {
            return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);
        }

        float map(vec3 p) {
            vec3 z = p;
            float dr = 1.0, r = 0.0;
            // 500 Iterations is an immense load for most mobile/integrated GPUs
            for (int i = 0; i < 500; i++) {
                r = length(z);
                if (r > 4.5) break;
                float theta = acos(z.z/r) * 8.0 + (uTime * 0.2);
                float phi = atan(z.y, z.x) * 8.0;
                dr = pow(r, 7.0) * 8.0 * dr + 1.0;
                float zr = pow(r, 8.0);
                z = zr * vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta)) + p;
                // Add tiny perturbations to prevent the GPU from optimizing the loop
                z += noise(z * 0.1) * 0.001; 
            }
            return 0.5 * log(r) * r / dr;
        }

        void main() {
            vec3 finalCol = vec3(0.0);
            // 16-Step Super Sampling
            for(int m=0; m < 16; m++) {
                vec2 offset = vec2(float(m) / 16.0, fract(float(m) * 0.3819));
                vec2 uv = (gl_FragCoord.xy + offset - 0.5 * uRes.xy) / uRes.y;
                
                vec3 ro = vec3(4.0 * cos(uTime*0.1), 2.5, 4.0 * sin(uTime*0.1));
                vec3 cw = normalize(-ro), cu = normalize(cross(cw, vec3(0,1,0))), cv = cross(cu, cw);
                vec3 rd = normalize(uv.x*cu + uv.y*cv + 2.5*cw);
                
                float t = 0.0;
                for(int i=0; i<180; i++) { 
                    float h = map(ro + rd*t);
                    if(h < 0.0001 || t > 12.0) break;
                    t += h;
                }
                if(t < 12.0) {
                    vec3 p = ro + rd*t;
                    vec2 e = vec2(0.0001, 0);
                    vec3 n = normalize(vec3(map(p+e.xyy)-map(p-e.xyy), map(p+e.yxy)-map(p-e.yxy), map(p+e.yyx)-map(p-e.yyx)));
                    float diff = max(dot(n, vec3(0.5, 0.8, 0.5)), 0.0);
                    finalCol += vec3(0.1, 0.8, 0.3) * diff;
                }
            }
            gl_FragColor = vec4(finalCol / 16.0, 1.0);
        }
    `;

    // Boilerplate setup
    const vs = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vs, vsSource); gl.compileShader(vs);
    const fs = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fs, fsSource); gl.compileShader(fs);
    const program = gl.createProgram();
    gl.attachShader(program, vs); gl.attachShader(program, fs);
    gl.linkProgram(program);
    gl.useProgram(program);

    let lastTime = 0, frameCount = 0;
    const fpsDisplay = document.getElementById('fps');

    function render(now) {
        now *= 0.001;
        frameCount++;
        if (now - lastTime >= 1.0) {
            fpsDisplay.innerText = Math.round(frameCount / (now - lastTime));
            frameCount = 0; lastTime = now;
        }

        gl.viewport(0, 0, canvas.width, canvas.height);
        const posLoc = gl.getAttribLocation(program, "pos");
        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        gl.uniform1f(gl.getUniformLocation(program, "uTime"), now);
        gl.uniform2f(gl.getUniformLocation(program, "uRes"), canvas.width, canvas.height);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
</script>
</body>
</html>
