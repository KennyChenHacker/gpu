<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>X-TREME GPU BENCHMARK</title>
    <style>
        body { margin: 0; background: #000; color: #ff003c; font-family: 'Courier New', monospace; overflow: hidden; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        #overlay {
            position: absolute; top: 15px; left: 15px;
            background: rgba(10, 0, 0, 0.85); padding: 20px;
            border: 2px solid #ff003c; border-radius: 10px; pointer-events: none;
            box-shadow: 0 0 15px rgba(255, 0, 60, 0.5);
        }

        .stat { font-size: 16px; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; }
        #fps { color: #fff; font-weight: bold; font-size: 32px; text-shadow: 0 0 10px #ff003c; }

        #warning {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: red; color: white; padding: 20px; display: none;
            font-weight: bold; text-align: center; border: 5px white solid;
        }
    </style>
</head>
<body>

<div id="overlay">
    <div class="stat">System FPS: <span id="fps">--</span></div>
    <div class="stat" id="load-text">TARGET: A19 PRO / DESKTOP GPU</div>
    <div class="stat" id="res-text">RENDER: 9x SUPERSAMPLED (EXTREME)</div>
</div>

<div id="warning">⚠️ THERMAL ALERT: DEVICE LAG DETECTED ⚠️</div>

<canvas id="glCanvas"></canvas>

<script>
    const canvas = document.getElementById('glCanvas');
    const gl = canvas.getContext('webgl');
    const fpsDisplay = document.getElementById('fps');
    const warning = document.getElementById('warning');
    let program;

    const vsSource = `attribute vec2 pos; void main() { gl_Position = vec4(pos, 0, 1); }`;

    // A19 EXTREME SETTINGS (HARDER)
    const ITERS = 260;   // fractal iterations (was max 150)
    const SSAA  = 9;     // supersampling (was max 4)
    const RM_STEPS = 180;

    const fsSource = `
        precision highp float;
        uniform float uTime;
        uniform vec2 uRes;

        float map(vec3 p) {
            vec3 z = p;
            float dr = 1.0, r = 0.0;
            for (int i = 0; i < ${ITERS}; i++) {
                r = length(z);
                if (r > 4.0) break;
                float theta = acos(z.z/r) * 9.0 + uTime * 0.08;
                float phi = atan(z.y, z.x) * 9.0;
                dr = pow(r, 8.0) * 9.0 * dr + 1.0;
                float zr = pow(r, 9.0);
                z = zr * vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta)) + p;
            }
            return 0.5 * log(r) * r / dr;
        }

        vec3 getNormal(vec3 p) {
            vec2 e = vec2(0.001, 0);
            return normalize(vec3(
                map(p+e.xyy)-map(p-e.xyy),
                map(p+e.yxy)-map(p-e.yxy),
                map(p+e.yyx)-map(p-e.yyx)
            ));
        }

        void main() {
            vec3 finalCol = vec3(0.0);
            float d_size = 1.0 / float(${SSAA});
            
            for(int m=0; m < ${SSAA}; m++) {
                for(int n=0; n < ${SSAA}; n++) {
                    vec2 uv = (gl_FragCoord.xy + vec2(float(m)*d_size, float(n)*d_size) - 0.5 * uRes.xy) / uRes.y;
                    vec3 ro = vec3(3.2 * cos(uTime*0.25), 1.7, 3.2 * sin(uTime*0.25));
                    vec3 cw = normalize(-ro), cu = normalize(cross(cw, vec3(0,1,0))), cv = cross(cu, cw);
                    vec3 rd = normalize(uv.x*cu + uv.y*cv + 2.0*cw);
                    
                    float t = 0.0;
                    for(int i=0; i<${RM_STEPS}; i++) {
                        float h = map(ro + rd*t);
                        if(h < 0.0003 || t > 10.0) break;
                        t += h;
                    }
                    if(t < 10.0) {
                        vec3 nrm = getNormal(ro + rd*t);
                        float diff = max(dot(nrm, vec3(0.6, 1.0, 0.5)), 0.0);
                        finalCol += vec3(0.9, 0.1, 0.2) * diff + 0.05;
                    }
                }
            }
            gl_FragColor = vec4(finalCol / float(${SSAA * SSAA}), 1.0);
        }
    `;

    const vs = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vs, vsSource); gl.compileShader(vs);
    const fs = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fs, fsSource); gl.compileShader(fs);

    program = gl.createProgram();
    gl.attachShader(program, vs); gl.attachShader(program, fs);
    gl.linkProgram(program);
    gl.useProgram(program);

    let lastTime = 0, frameCount = 0;
    function render(now) {
        now *= 0.001;
        const delta = now - lastTime;
        frameCount++;

        if (delta >= 1.0) {
            let fps = Math.round(frameCount / delta);
            fpsDisplay.innerText = fps;
            warning.style.display = fps < 15 ? "block" : "none";
            frameCount = 0;
            lastTime = now;
        }

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);

        const posLoc = gl.getAttribLocation(program, "pos");
        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1,-1, 1,-1, -1,1,
            -1,1, 1,-1, 1,1
        ]), gl.STATIC_DRAW);

        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        gl.uniform1f(gl.getUniformLocation(program, "uTime"), now);
        gl.uniform2f(gl.getUniformLocation(program, "uRes"), canvas.width, canvas.height);
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
</script>
</body>
</html>
