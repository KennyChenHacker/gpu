<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EXTREME GPU STRESS TEST</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #warning {
            position: absolute; top: 20px; left: 20px;
            color: #ff0000; background: rgba(0,0,0,0.8);
            padding: 15px; border: 2px solid #ff0000;
            font-weight: bold; pointer-events: none;
            text-transform: uppercase; letter-spacing: 2px;
        }
    </style>
</head>
<body>

<div id="warning">⚠️ EXTREME LOAD: GPU STRESS ACTIVE ⚠️</div>
<canvas id="glCanvas"></canvas>

<script>
    const canvas = document.getElementById('glCanvas');
    const gl = canvas.getContext('webgl');

    const vsSource = `attribute vec2 pos; void main() { gl_Position = vec4(pos, 0, 1); }`;

    // The hardest possible logic: Raymarching + 6x SSAA + High Precision Normals
    const fsSource = `
        precision highp float;
        uniform float uTime;
        uniform vec2 uRes;

        float map(vec3 p) {
            vec3 z = p;
            float dr = 1.0, r = 0.0;
            // 200 Iterations - significantly harder than the previous code
            for (int i = 0; i < 200; i++) {
                r = length(z);
                if (r > 4.0) break;
                float theta = acos(z.z/r) * 8.0 + uTime * 0.1;
                float phi = atan(z.y, z.x) * 8.0;
                dr = pow(r, 7.0) * 8.0 * dr + 1.0;
                float zr = pow(r, 8.0);
                z = zr * vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta)) + p;
            }
            return 0.5 * log(r) * r / dr;
        }

        void main() {
            vec3 finalCol = vec3(0.0);
            
            // 6x6 Supersampling = 36x more calculations PER PIXEL
            // This is what causes immediate lag on mobile GPUs
            for(int m=0; m < 6; m++) {
                for(int n=0; n < 6; n++) {
                    vec2 offset = vec2(float(m), float(n)) / 6.0;
                    vec2 uv = (gl_FragCoord.xy + offset - 0.5 * uRes.xy) / uRes.y;
                    
                    vec3 ro = vec3(3.5 * cos(uTime*0.1), 1.5, 3.5 * sin(uTime*0.1));
                    vec3 cw = normalize(-ro), cu = normalize(cross(cw, vec3(0,1,0))), cv = cross(cu, cw);
                    vec3 rd = normalize(uv.x*cu + uv.y*cv + 2.0*cw);
                    
                    float t = 0.0;
                    for(int i=0; i<150; i++) {
                        float h = map(ro + rd*t);
                        if(h < 0.0001 || t > 10.0) break;
                        t += h;
                    }
                    if(t < 10.0) {
                        finalCol += vec3(0.5 + 0.5*cos(uTime+t*1.5), 0.1, 0.2);
                    }
                }
            }
            gl_FragColor = vec4(finalCol / 36.0, 1.0);
        }
    `;

    function createShader(gl, type, source) {
        const s = gl.createShader(type);
        gl.shaderSource(s, source); gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(s));
            return null;
        }
        return s;
    }

    const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
    const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
    const program = gl.createProgram();
    gl.attachShader(program, vs); gl.attachShader(program, fs);
    gl.linkProgram(program);
    gl.useProgram(program);

    function render(now) {
        now *= 0.001;
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
        
        const posLoc = gl.getAttribLocation(program, "pos");
        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        gl.uniform1f(gl.getUniformLocation(program, "uTime"), now);
        gl.uniform2f(gl.getUniformLocation(program, "uRes"), canvas.width, canvas.height);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
</script>
</body>
</html>
