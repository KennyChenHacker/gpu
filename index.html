<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>X-TREME GPU BENCHMARK: GOD MODE</title>
    <style>
        body { margin: 0; background: #000; color: #ff003c; font-family: 'Courier New', monospace; overflow: hidden; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        #overlay {
            position: absolute; top: 15px; left: 15px;
            background: rgba(10, 0, 0, 0.9); padding: 20px;
            border: 2px solid #ff003c; border-radius: 2px; pointer-events: none;
            box-shadow: 0 0 25px rgba(255, 0, 60, 0.8);
            z-index: 10;
        }

        .stat { font-size: 14px; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 2px; }
        #fps { color: #fff; font-weight: bold; font-size: 42px; text-shadow: 0 0 20px #ff003c; }
        .danger { color: #ff003c; animation: blink 0.5s infinite; font-weight: bold; }

        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }

        #warning {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #ff003c; color: white; padding: 40px; display: none;
            font-weight: bold; text-align: center; border: 10px white double;
            font-size: 24px; z-index: 100; box-shadow: 0 0 100px red;
        }
    </style>
</head>
<body>

<div id="overlay">
    <div class="stat">STATUS: <span class="danger">MAXIMUM OVERLOAD</span></div>
    <div class="stat">FPS: <span id="fps">--</span></div>
    <div class="stat" id="load-text">ITERATIONS: 250</div>
    <div class="stat" id="res-text">SSAA: 8x (EXTREME)</div>
</div>

<div id="warning">⚠️ CRITICAL THERMAL SHUTDOWN IMMINENT ⚠️<br>GPU COMPROMISED</div>

<canvas id="glCanvas"></canvas>

<script>
    const canvas = document.getElementById('glCanvas');
    const gl = canvas.getContext('webgl');
    const fpsDisplay = document.getElementById('fps');
    const warning = document.getElementById('warning');
    let program;

    const vsSource = `attribute vec2 pos; void main() { gl_Position = vec4(pos, 0, 1); }`;

    // CRANKED TO MAX: Higher iters and more complex math
    const getFsSource = (iters, ssaa) => `
        precision highp float;
        uniform float uTime;
        uniform vec2 uRes;

        float map(vec3 p) {
            vec3 z = p;
            float dr = 1.0, r = 0.0;
            for (int i = 0; i < ${iters}; i++) {
                r = length(z);
                if (r > 4.0) break;
                // Complex power-8 Mandelbulb math
                float theta = acos(z.z/r) * 8.0 + uTime * 0.1;
                float phi = atan(z.y, z.x) * 8.0;
                dr = pow(r, 7.0) * 8.0 * dr + 1.0;
                float zr = pow(r, 8.0);
                z = zr * vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta)) + p;
            }
            return 0.5 * log(r) * r / dr;
        }

        vec3 getNormal(vec3 p) {
            vec2 e = vec2(0.0005, 0);
            return normalize(vec3(map(p+e.xyy)-map(p-e.xyy), map(p+e.yxy)-map(p-e.yxy), map(p+e.yyx)-map(p-e.yyx)));
        }

        void main() {
            vec3 finalCol = vec3(0.0);
            float d_size = 1.0 / float(${ssaa});
            
            // MASSIVE CONVOLUTION LOOP
            for(int m=0; m < ${ssaa}; m++) {
                vec2 uv = (gl_FragCoord.xy + vec2(float(m)*d_size) - 0.5 * uRes.xy) / uRes.y;
                vec3 ro = vec3(3.5 * cos(uTime*0.1), 2.0, 3.5 * sin(uTime*0.1));
                vec3 cw = normalize(-ro), cu = normalize(cross(cw, vec3(0,1,0))), cv = cross(cu, cw);
                vec3 rd = normalize(uv.x*cu + uv.y*cv + 2.0*cw);
                
                float t = 0.0;
                for(int i=0; i<150; i++) { // Increased Raymarching steps to 150
                    float h = map(ro + rd*t);
                    if(h < 0.0002 || t > 10.0) break;
                    t += h;
                }
                if(t < 10.0) {
                    vec3 n = getNormal(ro + rd*t);
                    float diff = max(dot(n, vec3(0.5, 1, 0.5)), 0.0);
                    float spec = pow(max(dot(reflect(rd, n), vec3(0.5, 1, 0.5)), 0.0), 32.0);
                    finalCol += (vec3(0.9, 0.05, 0.1) * diff + spec + 0.05);
                }
            }
            gl_FragColor = vec4(finalCol / float(${ssaa}), 1.0);
        }
    `;

    function initShader(iters, ssaa) {
        const vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vs, vsSource); gl.compileShader(vs);
        const fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fs, getFsSource(iters, ssaa)); gl.compileShader(fs);
        
        program = gl.createProgram();
        gl.attachShader(program, vs); gl.attachShader(program, fs);
        gl.linkProgram(program);
        gl.useProgram(program);
    }

    let lastTime = 0, frameCount = 0;
    function render(now) {
        now *= 0.001;
        const delta = now - lastTime;
        frameCount++;

        if (delta >= 1.0) {
            let fps = Math.round(frameCount / delta);
            fpsDisplay.innerText = fps;
            // The threshold for the "Warning" is higher now
            warning.style.display = fps < 24 ? "block" : "none";
            frameCount = 0;
            lastTime = now;
        }

        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
        
        const posLoc = gl.getAttribLocation(program, "pos");
        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        gl.uniform1f(gl.getUniformLocation(program, "uTime"), now);
        gl.uniform2f(gl.getUniformLocation(program, "uRes"), canvas.width, canvas.height);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(render);
    }

    // IMMEDIATELY START IN GOD MODE
    // 250 iterations, 8x SSAA. This will lag even high-end PCs.
    initShader(250, 8); 
    requestAnimationFrame(render);
</script>
</body>
</html>
