precision highp float;
uniform float uTime;
uniform vec2 uRes;

// EXTREME MATH: Forces the GPU to use high-precision registers for every pixel
float map(vec3 p) {
    vec3 z = p;
    float dr = 1.0;
    float r = 0.0;
    // Massive iteration count for extreme detail
    for (int i = 0; i < 150; i++) { 
        r = length(z);
        if (r > 4.0) break;
        float theta = acos(z.z/r) * 8.0 + uTime * 0.1;
        float phi = atan(z.y, z.x) * 8.0;
        dr = pow(r, 7.0) * 8.0 * dr + 1.0;
        float zr = pow(r, 8.0);
        z = zr * vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta)) + p;
    }
    return 0.5 * log(r) * r / dr;
}

// AMBIENT OCCLUSION: This forces 5 extra 'map' calls for EVERY pixel
float calculateAO(vec3 p, vec3 n) {
    float occ = 0.0;
    float sca = 1.0;
    for(int i=0; i<5; i++) {
        float hr = 0.01 + 0.12 * float(i)/4.0;
        float d = map(p + n * hr);
        occ += -(d - hr) * sca;
        sca *= 0.95;
    }
    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);
}

void main() {
    // SUPERSAMPLING: Rendering at a higher internal resolution
    vec3 finalCol = vec3(0.0);
    for(int m=0; m<2; m++) { // 2x2 Supersampling (4x the pixels!)
    for(int n=0; n<2; n++) {
        vec2 offset = vec2(float(m), float(n)) / 2.0 - 0.5;
        vec2 uv = (gl_FragCoord.xy + offset - 0.5 * uRes.xy) / uRes.y;
        
        vec3 ro = vec3(3.5 * cos(uTime*0.1), 2.0, 3.5 * sin(uTime*0.1));
        vec3 cw = normalize(-ro), cu = normalize(cross(cw, vec3(0,1,0))), cv = cross(cu, cw);
        vec3 rd = normalize(uv.x*cu + uv.y*cv + 2.0*cw);

        float t = 0.0;
        for(int i=0; i<128; i++) { // Deep Marching
            float h = map(ro + rd*t);
            if(h < 0.0001 || t > 10.0) break;
            t += h;
        }

        if(t < 10.0) {
            vec3 pos = ro + rd * t;
            // SHADOWS: Another loop inside the pixel shader
            float shad = 1.0;
            float st = 0.02;
            for(int i=0; i<30; i++) {
                float h = map(pos + vec3(0.5, 1.0, 0.5)*st);
                shad = min(shad, 16.0*h/st);
                st += h;
                if(shad < 0.001) break;
            }
            finalCol += vec3(0.1, 0.6, 1.0) * shad;
        }
    }
    }
    gl_FragColor = vec4(finalCol / 4.0, 1.0);
}
